% ntwkconfig = initialiseVisualCortexNetwork(layerconfig, inlayer, retina, retina_on, retina_off)
%
% Initialise a visual cortex network using specified layer configuration
% parameters, and an input layer specified by inlayer. The retina can be a
% single retina input, or else be split into retina_on and retina_off, to
% enable on and off centre surround inputs.
% Inputs:
%  layerconfig    - struct generated by the parameter configuration 
function ntwkconfig = initialiseVisualCortexNetwork(layerconfig, inlayer, retina, retina_on, retina_off)
   % TO DO: generalise calculation of covariance - each connection away
   % from input --> increased effective radius
   
   % TO DO: generalise calculating of variance between joint inputs to a
   % postsynaptic layer (see pg. 24 of Plasticity #3 notebook)
   [sz, spatialJitter, N, beta, lambda,    ...
    r, radiusdist, radiusparams,           ...
    T, dt, interval, intervalQ, initTime,  ...
    layernames, layerconns, layerdist,     ...
    estCov, initCovWithAnal, Ra,           ...
    plastic, wgtdist, wgtparams,           ...
    conndist, connparams,                  ...
    deldist, delparams, pspdelay]          ...
        = struct2v(layerconfig,'sz',        'spatialJitter',  'N',            ...
                               'beta',      'lambda',                         ...
                               'r',         'radiusdist',     'radiusparams', ...
                               'T',         'dt',                             ...
                               'interval',  'intervalQ',      'initTime',     ...
                               'layernames','layerconns',     'layerdist',    ...
                               'estCov',    'initCovWithAnal','Ra',           ...
                               'plastic',   'wgtdist',        'wgtparams',    ...
                               'conndist',  'connparams',                     ...
                               'deldist',   'delparams',      'pspdelay');
 
   tic; % time initialisation

   % Configure time variables 
   time           = dt:dt:T;                     % time vector for simulation
   interval       = min(length(time),interval);  % don't have more samples than time points
   intervalQ      = min(length(time),intervalQ); % don't have more samples than time points
   interval  = ternaryOp(interval>0,round(T/dt)/interval,Inf);  % interval between rate/wgt outputs
   intervalQ = ternaryOp(intervalQ>0,round(T/dt)/intervalQ,Inf);% interval between cov/mu outputs

   nconns       = size(layerconns,1);
   totaldelay   = 0;  % tracking total delay across layers
   
   % Add spatial jitter to location of cells with respect to input
   % (actually generate for all layers but currently only using for retina)
   for li=1:length(layernames)
      lname = layernames{li};
      cell_loc.(lname) = round(randn(prod(sz.(lname)),2)*spatialJitter.(lname));
   end

   %% Initialise connections
   %  - allocate memory for every presynaptic neuron 
   connlabels = cell2mat(layerconns);
   for ci=1:nconns
      pre       = layerconns{ci,1};
      post      = layerconns{ci,2};
      cxlabel   = [pre post];
      conns_    = cell(sz.(post));  % connection indices
      conns_loc = cell(sz.(post));  % 2D connection locations
      delay_    = cell(sz.(post));  % synapse/axonal delays
      wgts      = cell(sz.(post));  % current synaptic weights
           
      % Initialise connections, delays & weights 
      radii.(cxlabel) = zeros( prod(sz.(post)), 1 ); % record radii in case it's variable
      for i=1:prod(sz.(post))
         % if N is same for all neurons (i.e. fixed_norm), set std dev of N 
         % to 0, else set std dev of N to user requested value
         if strcmpi( conndist.(cxlabel), 'fixed_norm' )
            Nsigma = 0;
         else
            Nsigma = connparams.(cxlabel);
         end
         % in matlab it's faster to allocate to a cell array than to an object (cuz
         % object needs permissions check etc every time you assign)
         
         %  radiusdist   - if radius not homogeneous across layer it has this dist
         %  radiusparams - parameters of non-constant radius distribution
         if strcmpi( radiusdist.(cxlabel), 'constant' )
            radius = r.(cxlabel);
         elseif strcmpi( radiusdist.(cxlabel), 'gaussian' ) % params = [mean sigma]
            radius = randn( 1 ) * radiusparams.(cxlabel)(2) + r.(cxlabel);
            % if radius is less than 0 set it to the mean, then we're not
            % changing the expected mean radius with our lower bound
            radius = ternaryOp( radius < 0, r.(cxlabel), radius );
         elseif strcmpi( radiusdist.(cxlabel), 'constant' ) % params = [lowerbound upperbound]
            radius = rand( 1 ) * diff( radiusparams.(cxlabel) ) + radiusparams.(cxlabel)(1);
         else
            radius = r.(cxlabel);
         end
         radii.(cxlabel)(i) = radius;
         conns_loc{i} = initVisualCortexGaussianConnections(N.(cxlabel), radius, sz.(pre), sz.(post), i, Nsigma); 
         conns_{i}    = subv2ind(sz.(pre),conns_loc{i}); % convert 2D location index to univariate index
%         % Convert connection locations to be ordered by their layer A
%         % input neuron, so we can see the impact of layer A on others
%         if length(conns_{i})>1
%           % If the presyn layer has a SINGLE connection to the retina layer, order by retina neurons
%           if ~isempty(retina) && any(connlabels(:,2)==pre) ...
%            && any(connlabels(connlabels(:,2)==pre,1)==retina) ...
%            && N.([retina pre])==1
%             [~,order]       = sort(cell2mat(conns.([retina pre])(conns_{i})));
%             conns_loc{i}    = conns_loc{i}(order,:);
%             conns_{i}       = conns_{i}(order);
%           end
%         end
        delay_{i} = initAxonalDelay(sz.(post), i, sz.(pre), conns_loc{i}, deldist.(cxlabel), delparams.(cxlabel), layerdist.(cxlabel));
        wgts{i}   = initialiseVisualCortexConnections(conns_{i}, wgtdist.(cxlabel), wgtparams.(cxlabel));
         % initialise mean rate estimate using lambda
%          if plastic.(cxlabel) && estCov
%             mu.(cxlabel){i} = ones(numel(conns_{i}),1)*lambda.(pre);
%             sig.(cxlabel){i}= ones(numel(conns_{i}),1);
%             Q.(cxlabel){i}  = eye(numel(conns_{i}));
%          end
      end

      % Now allocate cells to structs (separated cell & struct for speed)
      % Note that rates have 1 timestep extra to allow for
      % recurrent & feedback networks, so that change in weights & Q
      % is calculated from previous timestep (else some changes will be 
      % calculated from half built rates)
      delays.(cxlabel)     = delay_;
      maxdelay.(cxlabel)   = 1 + pspdelay + ceil(max(cellfun(@max,delay_(:)))/dt); % max delay in timesteps
      % if estimating cov need time for signal to propagate through layers,
      % otherwise we just need enough history in rates to be able to pass a
      % delayed signal to the layer below
      if estCov
         totaldelay        = totaldelay + maxdelay.(cxlabel);
      else
         totaldelay        = max([ totaldelay maxdelay.(cxlabel) ]);
      end
      % Convert delays to indices (i.e. number of timesteps)
      delayinds.(cxlabel)  = cellfun(@(d) ceil(d/dt),delays.(cxlabel),'uniformoutput',false);
      conns.(cxlabel)      = conns_;                             % indices of presynaptic neurons
      synloc.(cxlabel)     = conns_loc;                          % location of presynaptic neurons
      weights.(cxlabel)    = wgts;                               % initial weight of synapse
      if ~exist('rates','var') || ~isfield(rates,pre)
         rates.(pre)       = ones(maxdelay.(cxlabel),prod(sz.(pre)))*lambda.(pre);  % set to background rate
      else
         % if presyn layer already exists from another connection, then use
         % the longest delay to determine how many samples we need in memory
         maxsz             = max([size(rates.(pre),1) maxdelay.(cxlabel)]); 
         maxdelay.(cxlabel)= maxsz; % update so cx delay matches rate info
         rates.(pre)       = ones(maxsz,prod(sz.(pre)))*lambda.(pre);  % set to background rate
      end
      co_inputs.(cxlabel)  = cell(0);
   end
   
   %% Initialise plasticity
   % if we have a retina and input, add that connection so we can include
   % in cov & rate calculations etc
   if exist('inlayer','var')      && ...
      ( exist('retina',    'var') && ~isempty(retina    ) ...
     || exist('retina_on', 'var') && ~isempty(retina_on ) ...
     || exist('retina_off','var') && ~isempty(retina_off) )
   
     % if just a single retina layer, add it to connection list, else if we
     % have on & off centre cells add both to list
     if ~isempty( retina )
         connlabels = [inlayer retina; connlabels];
         r.([inlayer retina])     = layerconfig.RF.kernel_size;
     elseif ~isempty( retina_on ) && ( retina_off )
         connlabels = [inlayer retina_on; inlayer retina_off; connlabels];
         r.([inlayer retina_on])  = layerconfig.RF.kernel_size;
         r.([inlayer retina_off]) = layerconfig.RF.kernel_size;
     end
   end
   for ci=1:nconns
      pre     = layerconns{ci,1};
      post    = layerconns{ci,2};
      cxlabel = [pre post];
      conns_  = conns.(cxlabel);
      % Init Q: for plastic layers we need input covariance - this can be 
      % estimated from input rates, or determined analytically. 
      if plastic.(cxlabel)
         % get all connections to presyn layer to calc presyn rates
         preconnlabel       = connlabels( connlabels(:,2)==pre, : );
         if size( preconnlabel, 1 ) >= 1
            % assume first conn is the FF conn, so use it to set input cov
            r_preconn       = r.( preconnlabel(1,:) );
         else
            r_preconn       = 0;
         end
         if estCov  % estimate from rates (keep track of current estimate)
            Q.(cxlabel)     = cell( prod(sz.(post)), 1 );
            mu.(cxlabel)    = cell( prod(sz.(post)), 1 );
            sig.(cxlabel)   = cell( prod(sz.(post)), 1 );
            if initCovWithAnal
               % if same number of conns to each postsyn neuron can do it
               % all at once, else do it in a loop
               if strcmpi( conndist.(cxlabel), 'fixed_norm' )
                  Q.(cxlabel)(:)    = setLinskerCov( sz.(pre), r_preconn, conns_ );
                  [mu.(cxlabel){:}] = deal( ones(prod(N.(cxlabel)),1)*lambda.(pre) );
                  [sig.(cxlabel){:}]= deal( ones(prod(N.(cxlabel)),1)*lambda.(pre) );
               elseif strcmpi( conndist.(cxlabel), 'unfixed_norm' )
                  Q.(cxlabel)(:)    = setLinskerCov( sz.(pre), r_preconn, conns_ );
                  for i=1:prod( sz.(post) )
                     nC = length( weights.(cxlabel){i} );
                     % poisson process has same mean & variance so init to same value
                     mu.(cxlabel){i}   = ones( nC, 1) * lambda.(pre);
                     sig.(cxlabel){i}  = ones( nC, 1) * lambda.(pre);
                  end
               end
            end
         else % determine analytically 
            % poisson process has same mean & variance so init to same value
            mu.(cxlabel)    = ones( prod(sz.(pre)), 1) * lambda.(pre);
            sig.(cxlabel)   = ones( prod(sz.(pre)), 1) * lambda.(pre);
%             scale.([pre post])= getCovDelayFilterScale(delparams.([pre post]),psp,r.(post),T,dt,sz.(pre));
            % E.g. cov btwn layer B neurons is determined by previous 
            % layers radius, A->B radius
            Q.(cxlabel)     = setLinskerCov(sz.(pre),r_preconn,conns_); %,scale.([pre post]));
         end
         % if we're estimating cov any impact of jointly inputting layers
         % will come out in the cov. if we're getting cov analytically we
         % gotta make it ourselves
         if estCov
            co_inputs.(cxlabel) = [];
         else
            co_inputs.(cxlabel)= getJointInputLayers( layerconfig, pre, post, connlabels, r );
         end
      end
   end
   
   for li=1:length(layernames)
     lname = layernames{li};
     if ~isfield(rates,lname)
        rates.(lname)     = ones(1,prod(sz.(lname)))*lambda.(lname);   % set past timesteps to mean rate     
     else
        rates.(lname)(:)  = lambda.(lname);   % set past timesteps to mean rate     
     end
     rates.(lname)(end,:) = layerconfig.Ra.(lname);   % set current timestep to background rate     
   end
   % Initialise first samples, because we build rates at time t from rates
   % at time t-1 to enable recurrent connections
   rates.(inlayer)(1,:)   = ones( 1, prod(sz.(inlayer)) ) * lambda.(inlayer); % set past timsteps of input to mean rate
   % if input type is natural image, provide timestep as a
   % parameter so we can tell whether to switch images
   if strcmpi(layerconfig.noisedist, 'natural')
      layerconfig.noiseparams = updateNaturalImageParams(layerconfig.noiseparams, 1); 
      if isempty(layerconfig.noiseparams{end})
         ntwkconfig = [];
         return;
      end
   end
   rates.(inlayer)(1,:) = toVec( generateVisualCortexInput(lambda.(inlayer), sz.(inlayer),...
                                  layerconfig.noisedist, layerconfig.noiseparams) );
   if ~isempty(retina)
      rates.(retina)(1,:)     = toVec( generateRetinaInput(sz.(retina), sz.(inlayer), [0 0], cell_loc.(retina),...
                                       Ra.(retina), rates.(inlayer), layerconfig.RF) );
   end
   if ~isempty(retina_on)
      rates.(retina_on)(1,:)  = toVec( generateRetinaInput(sz.(retina_on), sz.(inlayer), [0 0], cell_loc.(retina_on),...
                                       Ra.(retina_on), rates.(inlayer), layerconfig.RF) );
   end
   if ~isempty(retina_off) 
      rates.(retina_off)(1,:) = toVec( generateRetinaInput(sz.(retina_off), sz.(inlayer), [0 0], cell_loc.(retina_off),...
                                       Ra.(retina_off), rates.(inlayer), layerconfig.RF, true) );
   end
   initTime = initTime + totaldelay; % init input & cov matrices
   
   cprintf( 'Strings', printTime(toc, '\tInitialising visual cortex layers took') );

   % Copy config to network structure
   ntwkconfig  = v2struct(rates,      weights,  cell_loc, conns,     synloc, ...
                          totaldelay, maxdelay, time,     delayinds,         ...
                          initTime,   interval, intervalQ,                   ...
                          Q,          sig,      mu,       co_inputs,         ...
                          radii );

end
   

   
   
   
